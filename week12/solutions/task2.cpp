#include <iostream>
using namespace std;
void changeNr (int* p) { 
	/*
		Тъй като функцията получава указател към променлива от тип int
		ние можем да променим стойността на променливата, и понеже директно
		"боравим" с адреса на променливата -> тези промени ще се запазят.

		Ако вместо int* p , пишеше int p, то тогава щеше да се създаде
		нова променлива p, която е видима само във функцията и на нея
		щяхме да и променяме стойността, а не на същинската p.

		Всъщност невъзможността да се промени стойността на променлива през функция
		идва от факта, че като подаваме аргументи на функцията те се копират.
		ако те са от простите типове int, double, bool и т.н. техните стойности
		се копират и ние правим промени върху копията.
		Ако подадем указател обаче - неговата стойност е адрес на променлива.
		Указателят ЩЕ се копира (нищо ново под небето), но копираната променлива
		ще има същата стойност а именно адреса към който сочи и началния указател.
		Затова промените направени през указателя stick-ват (се запазват).
	*/
    if ((*p) % 2 == 0)
        *p = 0;
}

int main() {
    int first = 8;
    int second = 3;
    int* firstPointer = &first; /* в първия случай директно създаваме указателя със стойност = адреса на first */
    
    /* във втория, обаче, първо създаваме указателя, а после му придаваме стойност = адреса на second */
    int* secondPointer;
    secondPointer = &second;

    changeNr(firstPointer);
    changeNr(secondPointer);

    cout << "After change a is : " << first << endl;
    cout << "After change b is : " << second << endl;
    return 0;
}
