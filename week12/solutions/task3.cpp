#include <iostream>
using namespace std;
/* В някои случаи масивите и указателите са взаимно заменяеми.
   Погледнете този случай. Никъде не се указва, че някой от параметрите
   на тази функция е масив. Въпреки това ако си пуснете програмата, 
   тя ще върви безпроблемно. Защо?

   Всъщност масивите представляват специализирани указатели.
   int arr[] = {1, 2, 3, 4, 5, 6, 7} създава масив, но всъщност
   променливата arr е указател към адреса на първия елемент на масива.
   Т.е. ако напишем int* pointer = &arr[0] - която означава нека 
   pointer е указател и сочи към адреса на arr[0], то ще видите
   че (pointer == arr) == true. 

   Всъщност arr[i] е съкратен запис на *(arr + i).

   Ето още един интересен факт:
   тъй като arr[i] е равносилно на *(arr + i), 
   ние можем да правим нещо от сорта на i[arr]. КАКВО?!
   :D Да вместо да кажете: искам i-тият елемент на масива arr, 
   може да кажете искам ... не знам?. Но понеже arr + i == i + arr
   значи *(arr + i)  == *(i + arr)
*/

void printArr(int* arr, int size) {
    for (int i = 0; i < size; i++) {
        cout << "arr[" << i << "]: " << *(arr + i) << endl; // *(arr + i) == arr[i]
    }
}

void populateArr(int* arr, int size) {
    for (int i = 0; i < size; i++) {
        cin >> *(arr + i); // *(arr + i) == arr[i]
    }
}

int main() {
    int arr[10];
    int size;

    cout << "Enter size: " << endl;
    cin >> size;

    /* функцията приема указател към променлива от тип int 
       -> както вече казахме arr е указател към arr[0]. */
    populateArr(arr, size); 
    printArr(arr, size);

    return 0;
}
